// AdsPower多环境管理器 - 优化版本
const express = require('express');
const path = require('path');
const fs = require('fs');
const axios = require('axios');
const BrowserController = require('./lib/browser-controller');
const TaskRunner = require('./lib/task-runner');
const OpenAIClient = require('./lib/openai-client');
const DeepSeekClient = require('./deepseek-client');
const AdsPowerAPI = require('./lib/adspower-api');
const logger = require('./lib/logger');

// 初始化应用
const app = express();
const port = process.env.PORT || 3001; // 将默认端口从3000改为3001

// 中间件
app.use(express.static(path.join(__dirname, 'public')));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// 设置视图引擎
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');

// 存储运行中的环境
const environments = {};
const activeTasks = {};
const stateManagers = {};

// OpenAI API配置
const openaiApiKey = process.env.OPENAI_API_KEY || 'sk-mFN79QCQHZ7oCgC35bF3B5926b1f4fD6B2Ad7cBe4e45A425';
const openaiClient = new OpenAIClient(openaiApiKey);

// DeepSeek API配置
const deepseekApiKey = process.env.DEEPSEEK_API_KEY || 'sk-65f469482277473ab2d072ec7944f6b6';
const deepseekClient = new DeepSeekClient(deepseekApiKey);

// AdsPower API客户端
const adspowerApi = new AdsPowerAPI({
  baseUrl: 'http://localhost:50325/api/v1'
});

// 环境备注文件路径
const notesFilePath = path.join(__dirname, 'config', 'environment-notes.json');

// 检查AdsPower API连接状态
async function checkAdsPowerConnection() {
  console.log('正在检查AdsPower API连接状态...');
  
  try {
    const response = await axios.get('http://localhost:50325/api/v1/browser/list', { timeout: 5000 });
    
    if (response && response.data && response.data.code === 0) {
      console.log('✅ AdsPower API连接正常');
      return true;
    } else {
      console.error('❌ AdsPower API连接异常:', response?.data?.msg || '未知错误');
      return false;
    }
  } catch (error) {
    console.error('❌ 无法连接到AdsPower API:', error.message);
    return false;
  }
}

// 获取环境列表API
        totalEnvironments: allEnvironments.length,
        runningCount: runningCount
      }
    });
  } catch (error) {
    console.error('渲染主页时出错:', error);
    
    // 尝试检查AdsPower连接状态
    const isConnected = await checkAdsPowerConnection();
    
    if (!isConnected) {
      return res.render('error', {
        title: 'AdsPower 连接错误',
        message: 'AdsPower API连接失败，请确保AdsPower软件已启动并开启了API服务。',
        help: '请检查:<br>1. AdsPower软件是否已启动<br>2. API服务是否已启用(在AdsPower设置->API中启用)<br>3. API端口是否为50325',
        error: error.message
      });
    }
    
    // 即使出错也尝试渲染页面
    res.render('index', { 
      title: 'AdsPower 多环境管理器',
      environments: [],
      groups: [],
      error: error.message,
      selectedGroup: '',
      adspower: { connected: isConnected }
    });
  }
});

// 旧版UI
app.get('/old-ui', (req, res) => {
  // 获取环境分组
  adspowerApi.getGroups()
    .then(groups => {
      res.render('old-ui', { 
        title: 'AdsPower 多环境管理器 - 旧版界面',
        groups: groups.data || []
      });
    })
    .catch(error => {
      console.error('获取环境分组失败:', error);
      res.render('old-ui', { 
        title: 'AdsPower 多环境管理器 - 旧版界面',
        groups: []
      });
    });
});

// 加载环境备注
function loadEnvironmentNotes() {
  try {
    if (fs.existsSync(notesFilePath)) {
      const data = fs.readFileSync(notesFilePath, 'utf8');
      return JSON.parse(data);
    }
    return {};
  } catch (error) {
    console.error('加载环境备注失败:', error);
    return {};
  }
}

// 保存环境备注
function saveEnvironmentNotes(notes) {
  try {
    const configDir = path.dirname(notesFilePath);
    
    // 确保配置目录存在
    if (!fs.existsSync(configDir)) {
      fs.mkdirSync(configDir, { recursive: true });
    }
    
    fs.writeFileSync(notesFilePath, JSON.stringify(notes, null, 2), 'utf8');
    return true;
  } catch (error) {
    console.error('保存环境备注失败:', error);
    return false;
  }
}

// 加载任务模板
function loadTasks() {
  try {
    const tasksPath = path.join(__dirname, 'config', 'tasks.json');
    if (fs.existsSync(tasksPath)) {
      const data = fs.readFileSync(tasksPath, 'utf8');
      return JSON.parse(data);
    }
    return [];
  } catch (error) {
    console.error('加载任务模板失败:', error);
    return [];
  }
}

// 浏览器状态管理器
class BrowserStateManager {
  constructor() {
    this.history = [];
    this.navigationHistory = [];
    this.clickedElements = new Set();
    this.lastClickTime = 0;
  }

  recordNavigation(url) {
    this.navigationHistory.push({
      url,
      timestamp: Date.now()
    });
  }
  
  recordClick(selector) {
    this.clickedElements.add(selector);
    this.lastClickTime = Date.now();
    this.history.push({
      type: 'click',
      selector,
      timestamp: this.lastClickTime
    });
  }
  
  getLastNavigation() {
    if (this.navigationHistory.length === 0) return null;
    return this.navigationHistory[this.navigationHistory.length - 1];
  }
  
  hasClickedElement(selector) {
    return this.clickedElements.has(selector);
  }
  
  getTimeSinceLastClick() {
    if (this.lastClickTime === 0) return null;
    return Date.now() - this.lastClickTime;
  }
}

// 重新连接浏览器
async function reconnectBrowser(envId) {
  if (!environments[envId]) {
    return {
      success: false,
      error: `环境 ${envId} 不存在`
    };
  }
  
  console.log(`[${new Date().toLocaleTimeString()}] 尝试重新连接环境 ${envId}...`);
  
  // 更新重连计数
  environments[envId].reconnectCount = (environments[envId].reconnectCount || 0) + 1;
  
  // 获取新的WebSocket URL
  try {
    const response = await axios.get(`http://localhost:50325/api/v1/browser/start?user_id=${envId}&launch_args=["--no-sandbox"]`);
    
    if (response.data.code !== 0 || !response.data.data || !response.data.data.ws) {
      const errorMsg = `重新连接环境失败: ${response.data.msg || '未知错误'}`;
      console.error(`[${new Date().toLocaleTimeString()}] ${errorMsg}`);
      return {
        success: false,
        error: errorMsg
      };
    }
    
    const ws = response.data.data.ws;
    
    // 创建新的控制器
    const newController = new BrowserController();
    await newController.connect(ws);
    
    // 保存旧的URL
    const lastUrl = environments[envId].lastUrl;
    
    // 更新环境信息
    environments[envId].controller = newController;
    environments[envId].startTime = new Date();
    
    // 如果有上次访问的URL，尝试导航到该URL
    if (lastUrl) {
      try {
        console.log(`[${new Date().toLocaleTimeString()}] 尝试恢复上次URL: ${lastUrl}`);
        await newController.navigate(lastUrl);
        environments[envId].lastUrl = lastUrl;
      } catch (navError) {
        console.error(`[${new Date().toLocaleTimeString()}] 恢复URL失败:`, navError);
      }
    }
    
    console.log(`[${new Date().toLocaleTimeString()}] 环境 ${envId} 重新连接成功`);
    return {
      success: true
    };
  } catch (error) {
    console.error(`[${new Date().toLocaleTimeString()}] 重新连接环境 ${envId} 失败:`, error);
    return {
      success: false,
      error: error.message || '未知错误'
    };
  }
}

// 启动环境
app.post('/api/environments/:envId/start', async (req, res) => {
  const envId = req.params.envId;
  
  try {
    console.log(`接收到启动环境 ${envId} 的请求`);
    
    // 检查环境是否已经在运行
    if (environments[envId] && environments[envId].controller) {
      // 广播环境状态更新
      app.emit('environment_update', {
        id: envId,
        status: 'running',
        lastUrl: environments[envId].lastUrl || null,
        startTime: environments[envId].startTime || new Date()
      });
      
      return res.json({
        success: true,
        message: `环境 ${envId} 已经在运行中`
      });
    }
    
    // 使用AdsPower API启动浏览器
    const startResponse = await adspowerApi.startBrowser(envId);
    
    console.log("启动环境原始响应:", JSON.stringify(startResponse));
    
    // 首先检查API响应是否成功
    if (startResponse.code === 0) {
      console.log(`环境 ${envId} API启动成功，尝试获取WebSocket连接...`);
      
      // 尝试获取WebSocket连接信息 - 考虑多种可能的响应格式
      let wsEndpoint = null;
      
      // 情况1: 直接在data.ws.puppeteer中有WebSocket URL
      if (startResponse.data && startResponse.data.ws && startResponse.data.ws.puppeteer) {
        wsEndpoint = startResponse.data.ws.puppeteer;
        console.log(`从data.ws.puppeteer获取到WebSocket地址: ${wsEndpoint}`);
      } 
      // 情况2: 在ws.puppeteer中有WebSocket URL (没有data层级)
      else if (startResponse.ws && startResponse.ws.puppeteer) {
        wsEndpoint = startResponse.ws.puppeteer;
        console.log(`从ws.puppeteer获取到WebSocket地址: ${wsEndpoint}`);
      }
      
      if (wsEndpoint) {
        try {
          // 创建并初始化浏览器控制器
          const controller = new BrowserController(wsEndpoint, envId);
          await controller.initialize();
          
          // 保存环境信息
          environments[envId] = {
            controller,
            startTime: new Date(),
            reconnectCount: 0,
            notes: environments[envId]?.notes || ''
          };
          
          console.log(`环境 ${envId} 已成功启动并连接WebSocket`);
          
          // 广播环境状态更新
          app.emit('environment_update', {
            id: envId,
            status: 'running',
            lastUrl: null,
            startTime: environments[envId].startTime
          });
          
          // 返回成功响应
          return res.json({
            success: true,
            message: `环境 ${envId} 已成功启动`,
            hasWebSocket: true
          });
        } catch (wsError) {
          console.error(`连接WebSocket失败: ${wsError.message}`);
          
          // WebSocket连接失败，但API启动成功，也视为启动成功
          // 保存环境信息（无控制器）
          environments[envId] = {
            controller: null,
            startTime: new Date(),
            notes: environments[envId]?.notes || '',
            status: 'running'
          };
          
          return res.json({
            success: true,
            message: '环境已在AdsPower中启动，但无法通过WebSocket控制',
            hasWebSocket: false,
            error: wsError.message
          });
        }
      } else {
        console.log(`环境 ${envId} 启动成功，但无法获取WebSocket地址`);
        
        // 没有WebSocket地址，但API启动成功，也视为启动成功
        // 保存环境信息（无控制器）
        environments[envId] = {
          controller: null,
          startTime: new Date(),
          notes: environments[envId]?.notes || '',
          status: 'running'
        };
        
        return res.json({
          success: true,
          message: '环境已在AdsPower中启动，但无法通过WebSocket控制',
          hasWebSocket: false
        });
      }
    } else {
      // API启动失败
      const errorMsg = startResponse.msg || '未知原因';
      console.error(`环境 ${envId} API启动失败: ${errorMsg}`);
      throw new Error(`启动环境失败: ${errorMsg}`);
    }
  } catch (error) {
    console.error(`启动环境 ${envId} 失败:`, error);
    res.status(500).json({
      success: false,
      message: `启动环境 ${envId} 失败: ${error.message}`
    });
  }
});

// 保留当前的启动环境API端点，确保后向兼容性
app.post('/api/environment/start/:envId', async (req, res) => {
  const envId = req.params.envId;
  
  console.log(`收到请求: 启动环境 ${envId}`);
  
  try {
    // 检查环境是否已经在运行
    if (environments[envId] && environments[envId].controller && environments[envId].controller.browser) {
      try {
        // 尝试验证浏览器是否真的连接
        const isConnected = environments[envId].controller.browser.isConnected();
        
        if (isConnected) {
          console.log(`环境 ${envId} 已经在运行中`);
          
          // 获取当前页面URL作为附加信息
          let currentUrl = '';
          try {
            currentUrl = await environments[envId].controller.page.url();
          } catch (urlError) {
            console.error('获取当前页面URL失败:', urlError);
          }
          
          // 刷新环境的最后一次活动时间
          environments[envId].lastActivity = Date.now();
          
          return res.json({
            success: true,
            message: '环境已经在运行中',
            alreadyRunning: true,
            wsEndpoint: environments[envId].wsEndpoint,
            hasWebSocket: true,
            currentUrl: currentUrl
          });
        } else {
          console.log(`环境 ${envId} 浏览器连接已断开，重新启动...`);
          // 断开连接的情况，尝试关闭现有浏览器
          try {
            await environments[envId].controller.close();
          } catch (closeError) {
            console.error('关闭断开连接的浏览器失败:', closeError);
          }
          // 继续启动新的浏览器实例
        }
      } catch (connectionError) {
        console.error(`检查环境 ${envId} 连接状态失败:`, connectionError);
        // 继续启动新的浏览器实例
      }
    }
    
    console.log(`正在请求AdsPower启动环境 ${envId}...`);
    
    const apiResponse = await adspowerApi.startBrowser(envId);
    
    if (apiResponse.code !== 0) {
      console.error(`启动环境 ${envId} 失败:`, apiResponse);
      return res.json({
        success: false,
        message: `启动环境失败: ${apiResponse.msg || '未知错误'}`
      });
    }
    
    const wsEndpoint = apiResponse.data?.ws;
    
    if (!wsEndpoint) {
      console.error(`无法获取环境 ${envId} 的WebSocket地址`);
      
      if (apiResponse.data?.open_tab) {
        // 如果AdsPower API返回open_tab但没有ws地址，表示浏览器已在AdsPower中打开，但我们无法通过WebSocket控制
        console.log(`环境 ${envId} 已在AdsPower中启动，但无WebSocket控制`);
        
        // 更新环境状态
        if (!environments[envId]) {
          environments[envId] = {};
        }
        environments[envId].startTime = new Date();
        environments[envId].lastActivity = Date.now();
        environments[envId].wsEndpoint = null;
        
        return res.json({
          success: true,
          message: '环境已在AdsPower中启动，但无法通过WebSocket控制',
          hasWebSocket: false
        });
      }
      
      return res.json({
        success: false,
        message: '无法获取环境的WebSocket地址'
      });
    }
    
    // 连接到浏览器
    try {
      console.log(`正在连接到环境 ${envId} 的WebSocket: ${wsEndpoint}`);
      
      const controller = new BrowserController();
      await controller.connect(wsEndpoint);
      
      // 保存环境信息
      if (!environments[envId]) {
        environments[envId] = {};
      }
      
      environments[envId].controller = controller;
      environments[envId].startTime = new Date();
      environments[envId].lastActivity = Date.now();
      environments[envId].wsEndpoint = wsEndpoint;
      
      console.log(`环境 ${envId} 连接成功`);
      
      res.json({
        success: true,
        message: '环境已启动并连接成功',
        wsEndpoint: wsEndpoint,
        hasWebSocket: true
      });
    } catch (error) {
      console.error(`连接到环境 ${envId} 的浏览器失败:`, error);
      
      res.json({
        success: false,
        message: `连接浏览器失败: ${error.message}`
      });
    }
  } catch (error) {
    console.error(`启动环境 ${envId} 时出错:`, error);
    
    res.json({
      success: false,
      message: `启动环境时出错: ${error.message}`
    });
  }
});

// 停止环境
app.post('/api/environments/:envId/stop', async (req, res) => {
  const envId = req.params.envId;
  
  try {
    console.log(`接收到停止环境 ${envId} 的请求`);
    
    // 检查环境是否存在
    if (!environments[envId]) {
      return res.status(404).json({
        success: false,
        message: `环境 ${envId} 不存在或未启动`
      });
    }
    
    // 断开浏览器连接
    if (environments[envId].controller) {
      try {
        await environments[envId].controller.disconnect();
      } catch (disconnectError) {
        console.error(`断开环境 ${envId} 连接时出错:`, disconnectError);
      }
    }
    
    // 使用AdsPower API停止浏览器
    await adspowerApi.stopBrowser(envId);
    
    // 保留环境备注但移除控制器
    const notes = environments[envId].notes;
    environments[envId] = { notes };
    
    console.log(`环境 ${envId} 已成功停止`);
    
    // 返回成功响应
    res.json({
      success: true,
      message: `环境 ${envId} 已成功停止`
    });
  } catch (error) {
    console.error(`停止环境 ${envId} 失败:`, error);
    res.status(500).json({
      success: false,
      message: `停止环境 ${envId} 失败: ${error.message}`
    });
  }
});

// 元素探索器页面路由 - 直接集成到主应用
app.get('/element-explorer/:envId', async (req, res) => {
  const envId = req.params.envId;
  
  if (!environments[envId] || !environments[envId].controller) {
    return res.status(404).send(`环境 ${envId} 未运行，无法打开元素探索器`);
  }
  
  res.render('element-explorer', { envId });
});

// 获取页面截图
app.get('/api/element-explorer/:envId/screenshot', async (req, res) => {
  const envId = req.params.envId;
  const startTime = Date.now();
  
  try {
    if (!environments[envId] || !environments[envId].controller) {
      return res.status(404).json({ 
        success: false, 
        message: '环境未运行', 
        screenshot: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' 
      });
    }
    
    const controller = environments[envId].controller;
    
    // 添加错误处理和超时控制
    try {
      console.log(`获取环境 ${envId} 的元素检查器截图`);
      
      // 添加全局超时保护，防止请求永久卡住
      const globalTimeout = setTimeout(() => {
        if (!res.headersSent) {
          console.error(`获取截图全局超时(15秒)，强制返回`);
          res.json({
            success: false,
            message: '获取截图超时，请重试或重新连接浏览器',
            screenshot: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
            elements: []
          });
        }
      }, 15000);
      
      // 最多重试3次
      let retryCount = 0;
      const maxRetries = 2;
      let lastError = null;
      
      while (retryCount <= maxRetries) {
        try {
          if (retryCount > 0) {
            console.log(`尝试第 ${retryCount} 次重试获取截图...`);
            // 在重试前等待一小段时间
            await new Promise(resolve => setTimeout(resolve, 500));
          }
          
          // 检查页面是否仍然有效
          if (!controller.page || controller.page.isClosed?.() || !controller.browser || !controller.browser.isConnected?.()) {
            throw new Error('页面已关闭或无效，可能需要重新连接');
          }
          
          // 使用超时Promise包装所有page操作
          const pageOperationWithTimeout = async (operation, timeoutMs, errorMessage) => {
            return Promise.race([
              operation(),
              new Promise((_, reject) => setTimeout(() => reject(new Error(errorMessage)), timeoutMs))
            ]);
          };
          
          // 获取当前URL和页面尺寸 - 单独设置超时
          let url = '';
          let dimensions = { viewport: { width: 1024, height: 768 }, page: { width: 1024, height: 768 } };
          
          try {
            url = await pageOperationWithTimeout(
              () => controller.page.url(),
              3000,
              '获取页面URL超时'
            );
          } catch (urlError) {
            console.error('获取URL失败:', urlError.message);
            url = '获取URL失败';
          }
          
          try {
            dimensions = await pageOperationWithTimeout(
              () => controller.page.evaluate(() => {
                return {
                  viewport: {
                    width: window.innerWidth,
                    height: window.innerHeight
                  },
                  page: {
                    width: Math.max(
                      document.body.scrollWidth,
                      document.documentElement.scrollWidth,
                      document.body.offsetWidth,
                      document.documentElement.offsetWidth,
                      document.body.clientWidth,
                      document.documentElement.clientWidth
                    ),
                    height: Math.max(
                      document.body.scrollHeight,
                      document.documentElement.scrollHeight,
                      document.body.offsetHeight,
                      document.documentElement.offsetHeight,
                      document.body.clientHeight,
                      document.documentElement.clientHeight
                    )
                  }
                };
              }),
              3000,
              '获取页面尺寸超时'
            );
          } catch (dimensionsError) {
            console.error('获取页面尺寸失败:', dimensionsError.message);
            // 使用默认dimensions值
          }
          
          // 收集页面上所有可交互元素 - 单独设置超时
          let elements = [];
          try {
            elements = await pageOperationWithTimeout(
              () => controller.page.evaluate(() => {
                // 获取页面上所有可交互元素的选择器
                try {
                  const selectors = [
                    'a', 'button', '[role="button"]', 'input', 'select', 'textarea', '[tabindex]',
                    '[onclick]', '[role="link"]', '[role="checkbox"]', '[role="radio"]',
                    '[role="tab"]', '[role="menu"]', '[role="menuitem"]', '[role="option"]',
                    'area[href]', 'summary', 'details', '[contenteditable="true"]',
                    'iframe', 'label', '.clickable', '[class*="btn"]', '[class*="button"]', 
                    '[data-test]', '[data-testid]', '[data-qa]', '[aria-label]', 
                    'div[role]', 'span[role]'
                  ];
                  
                  // 查找所有匹配的元素，限制数量避免返回过多
                  const allElements = document.querySelectorAll(selectors.join(','));
                  const elements = Array.from(allElements).slice(0, 200);
                  
                  // 过滤掉不可见或太小的元素
                  return elements
                    .filter(el => {
                      try {
                        const rect = el.getBoundingClientRect();
                        const style = window.getComputedStyle(el);
                        return rect.width > 3 && rect.height > 3 && 
                              style.display !== 'none' && 
                              style.visibility !== 'hidden' && 
                              style.opacity !== '0' &&
                              el.offsetParent !== null;
                      } catch (e) {
                        return false;
                      }
                    })
                    .map((el, id) => {
                      try {
                        const rect = el.getBoundingClientRect();
                        
                        // 获取元素文本，包括直接子元素的文本
                        let text = el.innerText || el.textContent || '';
                        if (!text && el.value) text = el.value;
                        if (!text && el.placeholder) text = '(占位符: ' + el.placeholder + ')';
                        if (!text && el.alt) text = '(alt: ' + el.alt + ')';
                        if (!text && el.title) text = '(title: ' + el.title + ')';
                        if (!text && el.ariaLabel) text = '(aria: ' + el.ariaLabel + ')';
                        if (!text && el.name) text = '(name: ' + el.name + ')';
                        if (!text) text = '(无文本)';
                        
                        // 构建唯一选择器
                        let selector = '';
                        
                        // 如果元素有ID，使用ID选择器
                        if (el.id) {
                          selector = `#${CSS.escape(el.id)}`;
                        } 
                        // 否则尝试其他方法
                        else {
                          const tagName = el.tagName.toLowerCase();
                          
                          // 默认使用标签名
                          selector = tagName;
                          
                          // 添加元素属性
                          const selectorParts = [];
                          
                          if (el.type) selectorParts.push(`[type="${el.type}"]`);
                          if (el.name) selectorParts.push(`[name="${el.name}"]`);
                          if (el.role) selectorParts.push(`[role="${el.role}"]`);
                          if (el.className) {
                            const classes = el.className.trim().split(/\s+/).filter(Boolean);
                            if (classes.length > 0) {
                              selectorParts.push(`.${classes[0]}`); // 只使用第一个类名，简化选择器
                            }
                          }
                          
                          if (selectorParts.length > 0) {
                            selector = tagName + selectorParts[0]; // 只使用第一个选择器部分，避免过于复杂
                          }
                        }
                        
                        return {
                          id,
                          tagName: el.tagName.toLowerCase(),
                          text: text.trim().substring(0, 50), // 限制文本长度
                          selector,
                          rect: {
                            x: rect.left,
                            y: rect.top,
                            width: rect.width,
                            height: rect.height
                          },
                          type: el.type || '',
                          name: el.name || '',
                          role: el.getAttribute('role') || ''
                        };
                      } catch (e) {
                        return null;
                      }
                    })
                    .filter(Boolean); // 过滤掉空值
                } catch (mainError) {
                  console.error('获取元素主函数错误:', mainError);
                  return [];
                }
              }),
              5000,
              '获取页面元素超时'
            );
          } catch (elementsError) {
            console.error('获取元素失败:', elementsError.message);
            // 使用空数组
          }
          
          // 截取屏幕截图 - 单独设置超时
          let screenshot = '';
          try {
            screenshot = await pageOperationWithTimeout(
              () => controller.page.screenshot({ encoding: 'base64', fullPage: false }),
              5000,
              '截图操作超时'
            );
          } catch (ssError) {
            console.error('截图失败:', ssError.message);
            // 使用一个1x1透明的GIF作为回退
            screenshot = 'R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
          }
          
          // 清除全局超时
          clearTimeout(globalTimeout);
          
          // 返回成功响应
          res.json({
            success: true,
            screenshot: `data:image/png;base64,${screenshot}`,
            elements,
            url,
            dimensions,
            processingTime: Date.now() - startTime + 'ms'
          });
          
          // 成功获取截图，退出循环
          return;
        } catch (retryError) {
          lastError = retryError;
          retryCount++;
          console.error(`获取截图尝试 #${retryCount} 失败:`, retryError.message);
          
          // 如果是连接问题，尝试自动重连
          if (retryError.message.includes('连接') || 
              retryError.message.includes('WebSocket') || 
              retryError.message.includes('closed') ||
              retryError.message.includes('无效')) {
            
            console.log(`检测到连接问题，尝试自动重连环境 ${envId}...`);
            try {
              // 尝试重新连接浏览器
              const reconnectResult = await reconnectBrowser(envId);
              if (reconnectResult.success) {
                console.log(`自动重连成功，继续尝试获取截图...`);
                controller = environments[envId].controller; // 更新controller引用
              } else {
                console.error(`自动重连失败: ${reconnectResult.error}`);
              }
            } catch (reconnectError) {
              console.error(`自动重连出错:`, reconnectError);
            }
          }
        }
      }
      
      // 清除全局超时
      clearTimeout(globalTimeout);
      
      // 如果所有重试都失败，返回友好的错误响应
      console.error('所有截图尝试均失败，返回备用响应');
      res.json({
        success: false,
        message: `无法获取截图: ${lastError ? lastError.message : '未知错误'}`,
        screenshot: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        elements: [],
        url: '无法获取URL'
      });
    } catch (screenshotError) {
      console.error("截图失败:", screenshotError);
      // 返回友好的错误响应，而不是抛出异常
      res.json({
        success: false,
        message: `截图失败: ${screenshotError.message}`,
        screenshot: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
        elements: [],
        url: '无法获取'
      });
    }
  } catch (error) {
    console.error(`获取截图失败:`, error);
    res.status(200).json({ 
      success: false, 
      message: `获取截图失败: ${error.message}`,
      screenshot: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
    });
  }
});

// 获取页面元素
app.get('/api/element-explorer/elements/:envId', async (req, res) => {
  const envId = req.params.envId;
  const { query } = req.query;
  const startTime = Date.now();
  
  try {
    if (!environments[envId] || !environments[envId].controller) {
      return res.json({ 
        success: true, 
        data: [], 
        message: '环境未运行',
        timestamp: new Date().toISOString()
      });
    }
    
    const controller = environments[envId].controller;
    
    // 添加全局超时保护，防止请求永久卡住
    const globalTimeout = setTimeout(() => {
      if (!res.headersSent) {
        console.error(`获取元素全局超时(10秒)，强制返回`);
        res.json({ 
          success: true, 
          data: [], 
          message: '获取元素超时，请重试或重新连接浏览器',
          timestamp: new Date().toISOString()
        });
      }
    }, 10000);
    
    // 添加重试机制和错误处理
    let retryCount = 0;
    const maxRetries = 2;
    let lastError = null;
    
    while (retryCount <= maxRetries) {
      try {
        if (retryCount > 0) {
          console.log(`尝试第 ${retryCount} 次重试获取页面元素...`);
          // 在重试前等待一小段时间
          await new Promise(resolve => setTimeout(resolve, 500));
        }
        
        // 检查页面和浏览器是否仍然有效
        if (!controller.page || controller.page.isClosed?.() || 
            !controller.browser || !controller.browser.isConnected?.()) {
          throw new Error('页面已关闭或无效，可能需要重新连接');
        }
        
        console.log(`开始获取页面元素...(尝试 #${retryCount+1})`);
        
        // 使用超时Promise
        const elementsPromise = Promise.race([
          controller.page.evaluate((searchQuery) => {
            try {
              // 简化元素获取逻辑，提高性能
              const visibleElements = Array.from(document.querySelectorAll('a, button, input, select, textarea, [role], [tabindex], [onclick]'))
                .filter(el => {
                  try {
                    const rect = el.getBoundingClientRect();
                    const styles = window.getComputedStyle(el);
                    return rect.width > 0 && rect.height > 0 && 
                          styles.display !== 'none' && 
                          styles.visibility !== 'hidden';
                  } catch (err) {
                    return false; // 过滤出错的元素
                  }
                })
                .slice(0, 100)  // 限制数量，提高性能
                .map((el, i) => {
                  try {
                    const rect = el.getBoundingClientRect();
                    const tagName = el.tagName.toLowerCase();
                    
                    // 简化选择器计算
                    let selector = '';
                    if (el.id) {
                      selector = `#${el.id}`;
                    } else if (el.className && typeof el.className === 'string') {
                      const firstClass = el.className.split(' ')[0];
                      if (firstClass) {
                        selector = `${tagName}.${firstClass}`;
                      } else {
                        selector = tagName;
                      }
                    } else {
                      selector = tagName;
                    }
                    
                    return {
                      index: i,
                      tag: tagName,
                      id: el.id || '',
                      classes: (typeof el.className === 'string') ? el.className : '',
                      text: (el.textContent || '').trim().substring(0, 50),
                      rect: {
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height
                      },
                      selector: selector,
                      xpath: '/' + tagName
                    };
                  } catch (err) {
                    return null; // 如果某个元素处理失败，返回null
                  }
                })
                .filter(Boolean); // 过滤掉null值
                
              // 如果有搜索查询，过滤元素
              if (searchQuery) {
                const query = searchQuery.toLowerCase();
                return visibleElements.filter(el => 
                  el.text.toLowerCase().includes(query) || 
                  el.id.toLowerCase().includes(query) || 
                  el.classes.toLowerCase().includes(query) || 
                  el.tag.includes(query)
                );
              }
              
              return visibleElements;
            } catch (error) {
              console.error("获取元素过程中出错:", error);
              return []; // 返回空数组而不是让整个evaluate失败
            }
          }, query),
          new Promise((_, reject) => setTimeout(() => reject(new Error('获取元素操作超时')), 5000))
        ]);
        
        const elements = await elementsPromise;
        
        // 清除全局超时
        clearTimeout(globalTimeout);
        
        console.log("元素获取成功，数量:", elements ? elements.length : 0);
        
        // 返回成功响应
        res.json({ 
          success: true, 
          data: elements || [],
          timestamp: new Date().toISOString(),
          processingTime: Date.now() - startTime + 'ms'
        });
        
        // 成功时退出循环
        return;
      } catch (attemptError) {
        lastError = attemptError;
        retryCount++;
        console.error(`获取元素尝试 #${retryCount} 失败:`, attemptError.message);
        
        // 如果是连接问题，尝试自动重连
        if (attemptError.message.includes('连接') || 
            attemptError.message.includes('WebSocket') || 
            attemptError.message.includes('closed') ||
            attemptError.message.includes('无效')) {
          
          console.log(`检测到连接问题，尝试自动重连环境 ${envId}...`);
          try {
            // 尝试重新连接浏览器
            const reconnectResult = await reconnectBrowser(envId);
            if (reconnectResult.success) {
              console.log(`自动重连成功，继续尝试获取元素...`);
              controller = environments[envId].controller; // 更新controller引用
            } else {
              console.error(`自动重连失败: ${reconnectResult.error}`);
            }
          } catch (reconnectError) {
            console.error(`自动重连出错:`, reconnectError);
          }
        }
      }
    }
    
    // 清除全局超时
    clearTimeout(globalTimeout);
    
    // 如果所有重试都失败，返回友好的错误响应
    console.warn(`所有获取元素尝试均失败，返回空结果。最后错误: ${lastError?.message}`);
    res.json({ 
      success: true, 
      data: [], 
      message: `获取元素失败，请尝试重新连接: ${lastError ? lastError.message : '未知错误'}`,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error(`获取页面元素失败:`, error);
    res.json({ 
      success: true, 
      data: [], 
      message: `获取页面元素失败: ${error.message}`,
      timestamp: new Date().toISOString()
    });
  }
});

// 点击页面元素
app.post('/api/element-explorer/click/:envId', async (req, res) => {
  const envId = req.params.envId;
  const { selector } = req.body;
  
  try {
    if (!environments[envId] || !environments[envId].controller) {
      return res.status(404).json({ success: false, message: '环境未运行' });
    }
    
    if (!selector) {
      return res.status(400).json({ success: false, message: '缺少元素选择器' });
    }
    
    const controller = environments[envId].controller;
    
    // 尝试点击元素
    try {
      console.log(`尝试点击元素: ${selector}`);
      await controller.page.waitForSelector(selector, { timeout: 5000 });
      await controller.page.click(selector);
      console.log("元素点击成功");
      
      // 记录点击
      if (stateManagers[envId]) {
        stateManagers[envId].recordClick(selector);
      }
      
      res.json({ success: true, message: '元素点击成功' });
    } catch (clickError) {
      console.error("点击元素失败:", clickError);
      res.status(500).json({ success: false, message: `点击元素失败: ${clickError.message}` });
    }
  } catch (error) {
    console.error(`点击元素失败:`, error);
    res.status(500).json({ success: false, message: `点击元素失败: ${error.message}` });
  }
});

// 输入文本
app.post('/api/element-explorer/type-text/:envId', async (req, res) => {
  const envId = req.params.envId;
  const { selector, text } = req.body;
  
  try {
    if (!environments[envId] || !environments[envId].controller) {
      return res.status(404).json({ success: false, message: '环境未运行' });
    }
    
    if (!selector || text === undefined) {
      return res.status(400).json({ success: false, message: '缺少元素选择器或文本' });
    }
    
    const controller = environments[envId].controller;
    
    // 尝试输入文本
    try {
      console.log(`尝试在元素 ${selector} 中输入文本`);
      await controller.page.waitForSelector(selector, { timeout: 5000 });
      await controller.page.type(selector, text);
      console.log("文本输入成功");
      
      res.json({ success: true, message: '文本输入成功' });
    } catch (typeError) {
      console.error("输入文本失败:", typeError);
      res.status(500).json({ success: false, message: `输入文本失败: ${typeError.message}` });
    }
  } catch (error) {
    console.error(`输入文本失败:`, error);
    res.status(500).json({ success: false, message: `输入文本失败: ${error.message}` });
  }
});

// API: 获取环境列表及运行状态
app.get('/api/environments', async (req, res) => {
  try {
    // 获取分组ID过滤参数
    const groupId = req.query.group_id || '';
    console.log(`获取环境列表，分组过滤: ${groupId ? groupId : '全部'}`);
    
    // 实现完整的环境列表获取功能
    console.time('获取环境列表');
    const allEnvironments = await getAllEnvironments(groupId);
    console.timeEnd('获取环境列表');
    console.log(`总共获取到 ${allEnvironments.length} 个环境`);
    
    // 统计运行中的环境
    const runningEnvironments = Object.keys(environments).filter(id => 
      environments[id] && environments[id].controller).length;
    console.log(`运行中的环境: ${runningEnvironments}/${allEnvironments.length}`);
    
    // 增强环境数据，添加运行状态和备注信息
    const enhancedEnvironments = allEnvironments.map(env => {
      const envId = env.user_id;
      const isRunning = environments[envId] && environments[envId].controller ? true : false;
      
      return {
        ...env,
        id: envId,
        is_running: isRunning,
        notes: environments[envId]?.notes || ''
      };
    });
    
    // 返回响应
    console.log(`正在返回 ${enhancedEnvironments.length} 个环境到前端`);
    res.json({
      success: true,
      message: `成功获取 ${enhancedEnvironments.length} 个环境`,
      environments: enhancedEnvironments,
      running_count: runningEnvironments,
      total_count: allEnvironments.length
    });
  } catch (error) {
    console.error('获取环境列表失败:', error);
    res.json({
      success: false,
      message: `获取环境列表失败: ${error.message}`
    });
  }
});

/**
 * 获取所有环境，处理分页
 * @param {string} groupId 可选的分组ID过滤
 * @returns {Promise<Array>} 环境列表
 */
async function getAllEnvironments(groupId = '') {
  const allEnvironments = [];
  let page = 1;
  let hasMore = true;
  const pageSize = 100; // 每页请求100个环境
  let requestCount = 0;
  
  // 添加延迟函数
  const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
  
  // 记录开始时间
  const startTime = Date.now();
  
  while (hasMore && requestCount < 10) { // 限制最多10次请求，避免无限循环
    try {
      // 增加请求计数
      requestCount++;
      
      // 每次请求之间添加延迟，避免触发AdsPower API的速率限制
      if (page > 1) {
        const delayTime = 2000;
        console.log(`请求第${page}页前等待${delayTime}ms...`);
        await delay(delayTime);
      }
      
      console.log(`请求环境列表第 ${page} 页，每页 ${pageSize} 条记录...`);
      
      // 调用AdsPower API获取当前页的环境列表
      const options = {
        group_id: groupId,
        page: page,
        page_size: pageSize
      };
      
      const apiResponse = await adspowerApi.getEnvironmentList(options);
      
      if (apiResponse.code !== 0) {
        console.error(`获取第 ${page} 页环境失败:`, apiResponse);
        // 如果是第一页就失败了，可能需要重试一次
        if (page === 1 && requestCount < 3) {
          console.log(`第一页请求失败，等待3秒后重试...`);
          await delay(3000);
          continue; // 保持在第一页，重试请求
        }
        break;
      }
      
      // 提取环境列表
      let envList = [];
      if (apiResponse.data && Array.isArray(apiResponse.data.list)) {
        envList = apiResponse.data.list;
      } else if (Array.isArray(apiResponse.data)) {
        envList = apiResponse.data;
      } else {
        console.error(`获取第 ${page} 页环境返回格式异常:`, apiResponse);
        if (page === 1 && requestCount < 3) {
          console.log(`第一页格式异常，等待3秒后重试...`);
          await delay(3000);
          continue;
        }
      }
      
      console.log(`第 ${page} 页获取到 ${envList.length} 个环境`);
      
      // 添加到总环境列表
      allEnvironments.push(...envList);
      
      // 判断是否还有更多环境
      if (envList.length < pageSize) {
        console.log(`第 ${page} 页数据少于每页大小(${pageSize})，认为已获取所有数据`);
        hasMore = false;
      } else {
        page++;
      }
    } catch (error) {
      console.error(`获取环境列表第 ${page} 页出错:`, error);
      
      // 如果是第一页就失败了，可能需要重试
      if (page === 1 && requestCount < 3) {
        console.log(`第一页请求异常，等待3秒后重试...`);
        await delay(3000);
        continue; // 保持在第一页，重试请求
      }
      
      break;
    }
  }
  
  // 记录总用时
  const totalTime = Date.now() - startTime;
  console.log(`获取全部环境列表完成，共 ${allEnvironments.length} 个环境，耗时 ${totalTime}ms，请求了 ${requestCount} 次`);
  
  return allEnvironments;
}

// 批量启动环境
app.post('/api/environment/batch-start', async (req, res) => {
  try {
    const { envIds } = req.body;
    
    if (!envIds || !Array.isArray(envIds) || envIds.length === 0) {
      return res.json({
        success: false,
        message: '请提供有效的环境ID列表'
      });
    }
    
    console.log(`批量启动 ${envIds.length} 个环境: ${envIds.join(', ')}`);
    
    // 启动每个环境
    const startPromises = envIds.map(envId => {
      return new Promise(async (resolve) => {
        try {
          // 检查环境是否已经在运行
          if (environments[envId] && environments[envId].controller) {
            console.log(`环境 ${envId} 已经在运行中，跳过启动`);
            resolve({ id: envId, success: true, message: '环境已在运行中' });
            return;
          }
          
          // 启动环境
          const startResponse = await adspowerApi.openBrowser(envId);
          
          if (!startResponse || !startResponse.data || !startResponse.data.ws) {
            throw new Error('启动环境失败: 无法获取WebSocket地址');
          }
          
          const wsEndpoint = startResponse.data.ws.puppeteer;
          
          // 创建浏览器控制器
          const controller = new BrowserController(wsEndpoint, envId);
          await controller.initialize();
          
          // 保存环境信息
          environments[envId] = {
            controller,
            startTime: new Date(),
            name: `环境 ${envId}`,
            notes: environments[envId]?.notes || ''
          };
          
          console.log(`环境 ${envId} 启动成功`);
          resolve({ id: envId, success: true });
        } catch (error) {
          console.error(`启动环境 ${envId} 失败:`, error);
          resolve({ id: envId, success: false, message: error.message });
        }
      });
    });
    
    // 等待所有环境启动完成
    const results = await Promise.all(startPromises);
    
    // 统计成功和失败的数量
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.length - successCount;
    
    res.json({
      success: true,
      message: `批量启动完成: ${successCount} 个成功, ${failureCount} 个失败`,
      results
    });
  } catch (error) {
    console.error('批量启动环境失败:', error);
    res.json({
      success: false,
      message: `批量启动环境失败: ${error.message}`
    });
  }
});

// 批量停止环境
app.post('/api/environment/batch-stop', async (req, res) => {
  try {
    const { envIds } = req.body;
    
    if (!envIds || !Array.isArray(envIds) || envIds.length === 0) {
      return res.json({
        success: false,
        message: '请提供有效的环境ID列表'
      });
    }
    
    console.log(`批量停止 ${envIds.length} 个环境: ${envIds.join(', ')}`);
    
    // 停止每个环境
    const stopPromises = envIds.map(envId => {
      return new Promise(async (resolve) => {
        try {
          // 检查环境是否在运行
          if (!environments[envId] || !environments[envId].controller) {
            console.log(`环境 ${envId} 未在运行中，跳过停止`);
            resolve({ id: envId, success: true, message: '环境未在运行中' });
            return;
          }
          
          // 停止环境
          await adspowerApi.closeBrowser(envId);
          
          // 关闭浏览器控制器
          if (environments[envId].controller) {
            await environments[envId].controller.close();
            environments[envId].controller = null;
          }
          
          console.log(`环境 ${envId} 停止成功`);
          resolve({ id: envId, success: true });
        } catch (error) {
          console.error(`停止环境 ${envId} 失败:`, error);
          
          // 即使API调用失败，也尝试关闭控制器
          if (environments[envId] && environments[envId].controller) {
            try {
              await environments[envId].controller.close();
              environments[envId].controller = null;
            } catch (closeError) {
              console.error(`关闭环境 ${envId} 控制器失败:`, closeError);
            }
          }
          
          resolve({ id: envId, success: false, message: error.message });
        }
      });
    });
    
    // 等待所有环境停止完成
    const results = await Promise.all(stopPromises);
    
    // 统计成功和失败的数量
    const successCount = results.filter(r => r.success).length;
    const failureCount = results.length - successCount;
    
    res.json({
      success: true,
      message: `批量停止完成: ${successCount} 个成功, ${failureCount} 个失败`,
      results
    });
  } catch (error) {
    console.error('批量停止环境失败:', error);
    res.json({
      success: false,
      message: `批量停止环境失败: ${error.message}`
    });
  }
});

// 获取环境日志
app.get('/api/logs/:envId', (req, res) => {
  const envId = req.params.envId;
  
  if (!envId) {
    return res.json({
      success: false,
      message: '请提供环境ID'
    });
  }
  
  // 获取环境日志
  const logFilePath = path.join(__dirname, 'logs', `env-${envId}.log`);
  
  try {
    if (!fs.existsSync(logFilePath)) {
      return res.json({
        success: true,
        logs: []
      });
    }
    
    // 读取日志文件
    const logContent = fs.readFileSync(logFilePath, 'utf8');
    const logLines = logContent.split('\n').filter(line => line.trim());
    
    // 解析日志
    const logs = logLines.map(line => {
      try {
        return JSON.parse(line);
      } catch (e) {
        return {
          timestamp: new Date().toISOString(),
          level: 'error',
          message: line
        };
      }
    }).slice(-100); // 只返回最后100条日志
    
    res.json({
      success: true,
      logs
    });
  } catch (error) {
    console.error(`获取环境 ${envId} 日志失败:`, error);
    res.json({
      success: false,
      message: `获取环境日志失败: ${error.message}`
    });
  }
});

// 停止单个环境
app.post('/api/environment/stop/:envId', async (req, res) => {
  try {
    const envId = req.params.envId;
    
    if (!envId) {
      return res.json({
        success: false,
        message: '请提供环境ID'
      });
    }
    
    console.log(`停止环境: ${envId}`);
    
    // 检查环境是否在运行
    if (!environments[envId] || !environments[envId].controller) {
      return res.json({
        success: true,
        message: '环境未在运行中'
      });
    }
    
    // 停止环境
    await adspowerApi.closeBrowser(envId);
    
    // 关闭浏览器控制器
    if (environments[envId].controller) {
      await environments[envId].controller.close();
      environments[envId].controller = null;
    }
    
    console.log(`环境 ${envId} 停止成功`);
    
    res.json({
      success: true,
      message: '环境停止成功'
    });
  } catch (error) {
    console.error(`停止环境失败:`, error);
    
    // 即使API调用失败，也尝试关闭控制器
    if (environments[req.params.envId] && environments[req.params.envId].controller) {
      try {
        await environments[req.params.envId].controller.close();
        environments[req.params.envId].controller = null;
      } catch (closeError) {
        console.error(`关闭环境控制器失败:`, closeError);
      }
    }
    
    res.json({
      success: false,
      message: `停止环境失败: ${error.message}`
    });
  }
});

// 获取AI模型列表
app.get('/api/ai/models', (req, res) => {
  try {
    // 定义可用的AI模型
    const models = [
      {
        id: 'openai',
        name: 'OpenAI GPT-4',
        description: 'OpenAI的GPT-4模型',
        disabled: !openaiApiKey
      },
      {
        id: 'deepseek',
        name: 'DeepSeek',
        description: 'DeepSeek AI模型',
        disabled: !deepseekApiKey
      }
    ];
    
    // 确定默认模型
    let defaultModelId = 'openai';
    if (!openaiApiKey && deepseekApiKey) {
      defaultModelId = 'deepseek';
    }
    
    res.json({
      success: true,
      models,
      defaultModelId
    });
  } catch (error) {
    console.error('获取AI模型列表失败:', error);
    res.json({
      success: false,
      message: `获取AI模型列表失败: ${error.message}`,
      models: []
    });
  }
});

// 执行AI命令
app.post('/api/ai/execute', async (req, res) => {
  try {
    const { envId, modelId, command } = req.body;
    
    if (!envId) {
      return res.json({
        success: false,
        message: '请提供环境ID'
      });
    }
    
    if (!command) {
      return res.json({
        success: false,
        message: '请提供AI命令'
      });
    }
    
    // 检查环境是否在运行
    if (!environments[envId] || !environments[envId].controller) {
      return res.json({
        success: false,
        message: '环境未在运行中'
      });
    }
    
    console.log(`执行AI命令: ${command} (环境: ${envId}, 模型: ${modelId || 'default'})`);
    
    // 获取当前页面URL
    const currentUrl = await environments[envId].controller.getCurrentUrl();
    
    // 准备上下文信息
    const context = {
      url: currentUrl,
      envId,
      timestamp: new Date().toISOString()
    };
    
    // 根据选择的模型执行命令
    let aiResponse;
    if (modelId === 'deepseek' && deepseekApiKey) {
      aiResponse = await deepseekClient.generateText(command, context);
    } else {
      // 默认使用OpenAI
      aiResponse = await openaiClient.generateText(command, context);
    }
    
    // 记录响应
    console.log(`AI响应: ${aiResponse.substring(0, 100)}${aiResponse.length > 100 ? '...' : ''}`);
    
    // 解析响应中的代码部分
    const codeMatch = aiResponse.match(/```(?:javascript|js)?\s*([\s\S]*?)```/);
    const code = codeMatch ? codeMatch[1].trim() : null;
    
    // 如果有代码，尝试执行
    let result = null;
    if (code) {
      try {
        console.log(`执行代码: ${code.substring(0, 100)}${code.length > 100 ? '...' : ''}`);
        result = await environments[envId].controller.executeScript(code);
        console.log(`代码执行结果: ${JSON.stringify(result).substring(0, 100)}`);
      } catch (execError) {
        console.error('代码执行失败:', execError);
        result = { error: execError.message };
      }
    }
    
    res.json({
      success: true,
      response: aiResponse,
      code,
      result: result ? JSON.stringify(result) : null
    });
  } catch (error) {
    console.error('执行AI命令失败:', error);
    res.json({
      success: false,
      message: `执行AI命令失败: ${error.message}`
    });
  }
});

// 执行任务
app.post('/api/task/execute', async (req, res) => {
  try {
    const { envId, taskId } = req.body;
    
    if (!envId || !taskId) {
      return res.json({
        success: false,
        message: '请提供环境ID和任务ID'
      });
    }
    
    // 检查环境是否在运行
    if (!environments[envId] || !environments[envId].controller) {
      return res.json({
        success: false,
        message: '环境未在运行中'
      });
    }
    
    // 检查是否已有任务在运行
    if (activeTasks[envId]) {
      return res.json({
        success: false,
        message: '该环境已有任务在运行中'
      });
    }
    
    // 加载任务
    const tasks = loadTasks();
    const task = tasks.find(t => t.id === taskId);
    
    if (!task) {
      return res.json({
        success: false,
        message: '未找到指定任务'
      });
    }
    
    console.log(`执行任务: ${task.name} (环境: ${envId})`);
    
    // 创建任务执行ID
    const executionId = `${taskId}-${Date.now()}`;
    
    // 创建任务运行器
    const taskRunner = new TaskRunner(environments[envId].controller, task);
    
    // 保存到活动任务
    activeTasks[envId] = {
      id: executionId,
      taskId,
      taskName: task.name,
      startTime: new Date(),
      status: 'running',
      logs: []
    };
    
    // 异步执行任务
    taskRunner.run()
      .then(result => {
        console.log(`任务 ${task.name} 执行完成:`, result);
        
        if (activeTasks[envId]) {
          activeTasks[envId].status = 'completed';
          activeTasks[envId].endTime = new Date();
          activeTasks[envId].result = result;
          
          // 5分钟后清除任务记录
          setTimeout(() => {
            if (activeTasks[envId] && activeTasks[envId].id === executionId) {
              delete activeTasks[envId];
            }
          }, 5 * 60 * 1000);
        }
      })
      .catch(error => {
        console.error(`任务 ${task.name} 执行失败:`, error);
        
        if (activeTasks[envId]) {
          activeTasks[envId].status = 'failed';
          activeTasks[envId].endTime = new Date();
          activeTasks[envId].error = error.message;
          
          // 5分钟后清除任务记录
          setTimeout(() => {
            if (activeTasks[envId] && activeTasks[envId].id === executionId) {
              delete activeTasks[envId];
            }
          }, 5 * 60 * 1000);
        }
      });
    
    res.json({
      success: true,
      message: '任务开始执行',
      executionId
    });
  } catch (error) {
    console.error('执行任务失败:', error);
    res.json({
      success: false,
      message: `执行任务失败: ${error.message}`
    });
  }
});

// 获取任务状态
app.get('/api/task/status/:executionId', (req, res) => {
  try {
    const executionId = req.params.executionId;
    
    if (!executionId) {
      return res.json({
        success: false,
        message: '请提供执行ID'
      });
    }
    
    // 查找任务
    let taskInfo = null;
    let envId = null;
    
    for (const [id, task] of Object.entries(activeTasks)) {
      if (task.id === executionId) {
        taskInfo = task;
        envId = id;
        break;
      }
    }
    
    if (!taskInfo) {
      return res.json({
        success: false,
        message: '未找到指定任务执行记录'
      });
    }
    
    res.json({
      success: true,
      status: taskInfo.status,
      taskId: taskInfo.taskId,
      taskName: taskInfo.taskName,
      startTime: taskInfo.startTime,
      endTime: taskInfo.endTime,
      logs: taskInfo.logs || [],
      result: taskInfo.result,
      errorMessage: taskInfo.error
    });
  } catch (error) {
    console.error('获取任务状态失败:', error);
    res.json({
      success: false,
      message: `获取任务状态失败: ${error.message}`
    });
  }
});

// 元素检查器 - 获取指定坐标的元素
app.post('/api/element-explorer/:envId/element-at-point', async (req, res) => {
  const envId = req.params.envId;
  const { x, y } = req.body;
  
  console.log(`获取环境 ${envId} 中坐标 (${x}, ${y}) 的元素`);
  
  try {
    // 检查环境是否存在并运行
    if (!environments[envId] || !environments[envId].controller || !environments[envId].controller.page) {
      throw new Error(`环境 ${envId} 不存在或未运行`);
    }
    
    const controller = environments[envId].controller;
    
    // 在页面中获取该坐标点的元素信息
    const elementInfo = await controller.page.evaluate((coordX, coordY) => {
      // 获取指定坐标的元素
      const element = document.elementFromPoint(coordX, coordY);
      
      if (!element) {
        return null;
      }
      
      // 获取元素矩形
      const rect = element.getBoundingClientRect();
      
      // 构建选择器
      let selector = '';
      
      // ID选择器（如果有ID）
      if (element.id) {
        selector = `#${element.id}`;
      } 
      // 否则尝试其他方法
      else {
        const tagName = element.tagName.toLowerCase();
        
        // 默认使用标签名
        selector = tagName;
        
        // 添加元素属性
        const selectorParts = [];
        
        if (element.type) selectorParts.push(`[type="${element.type}"]`);
        if (element.name) selectorParts.push(`[name="${element.name}"]`);
        if (element.role) selectorParts.push(`[role="${element.role}"]`);
        if (element.className) {
          const classes = element.className.trim().split(/\s+/)[0];
          if (classes) selectorParts.push(`.${classes}`);
        }
        
        if (selectorParts.length > 0) {
          selector = tagName + selectorParts.join('');
        }
      }
      
      // 获取XPath
      let xpath = '';
      try {
        let el = element;
        let path = [];
        while (el && el.nodeType === Node.ELEMENT_NODE) {
          let idx = 0;
          let sibling = el.previousSibling;
          while (sibling) {
            if (sibling.nodeType === Node.ELEMENT_NODE && sibling.tagName === el.tagName) {
              idx++;
            }
            sibling = sibling.previousSibling;
          }
          
          let tagName = el.tagName.toLowerCase();
          let pathIndex = (idx ? `[${idx + 1}]` : '');
          path.unshift(`${tagName}${pathIndex}`);
          
          el = el.parentNode;
        }
        
        xpath = `//${path.join('/')}`;
      } catch (e) {
        xpath = '无法生成XPath';
      }
      
      return {
        tagName: element.tagName.toLowerCase(),
        type: element.type || '',
        text: (element.textContent || '').trim().substring(0, 50),
        selector,
        xpath: xpath,
        rect: {
          x: rect.left,
          y: rect.top,
          width: rect.width,
          height: rect.height
        },
        attributes: {
          id: element.id || '',
          class: element.className || '',
          name: element.name || '',
          href: element.href || '',
          placeholder: element.placeholder || '',
          value: element.value || '',
          type: element.type || '',
          role: element.getAttribute('role') || ''
        }
      };
    }, x, y);
    
    // 查找匹配的元素索引
    const allElements = await controller.page.evaluate(() => {
      const selectors = [
        'a', 'button', 'input', 'select', 'textarea', 
        '[role="button"]', '[role="link"]', '[role="checkbox"]',
        '[role="radio"]', '[role="tab"]', '[role="menuitem"]',
        'form', 'iframe', 'img[alt]', 'label',
        'div[class*="btn"]', 'div[class*="button"]',
        'span[class*="btn"]', 'span[class*="button"]',
        '[class*="clickable"]', '[class*="selectable"]', 
        '[onclick]', '[tabindex]'
      ];
      
      const allElements = document.querySelectorAll(selectors.join(', '));
      
      return Array.from(allElements)
        .map((el, index) => {
          const rect = el.getBoundingClientRect();
          return {
            id: index,
            tagName: el.tagName.toLowerCase(),
            type: el.type || '',
            selector: el.id ? `#${el.id}` : (el.className ? `.${el.className.split(' ')[0]}` : el.tagName.toLowerCase()),
            rect: {
              x: rect.left,
              y: rect.top,
              width: rect.width,
              height: rect.height
            },
            attributes: {
              id: el.id || '',
              class: el.className || ''
            }
          };
        });
    });
    
    // 找到匹配的元素索引
    let matchedElementIndex = -1;
    if (elementInfo && allElements) {
      // 尝试通过ID或类选择器匹配
      matchedElementIndex = allElements.findIndex(el => 
        (elementInfo.attributes.id && el.attributes.id === elementInfo.attributes.id) ||
        (elementInfo.attributes.class && el.attributes.class === elementInfo.attributes.class) ||
        (el.rect.x === elementInfo.rect.x && 
         el.rect.y === elementInfo.rect.y && 
         el.rect.width === elementInfo.rect.width && 
         el.rect.height === elementInfo.rect.height)
      );
    }
    
    if (elementInfo) {
      elementInfo.matchedElementIndex = matchedElementIndex;
    }
    
    res.json({
      success: true,
      element: elementInfo,
      matchedElementIndex: matchedElementIndex
    });
  } catch (error) {
    console.error(`获取元素信息失败:`, error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// 元素检查器点击元素API
app.post('/api/element-explorer/:envId/click', async (req, res) => {
  const envId = req.params.envId;
  const { selector } = req.body;
  
  console.log(`点击环境 ${envId} 中的元素: ${selector}`);
  
  try {
    // 检查环境是否存在
    if (!environments[envId]) {
      throw new Error(`环境 ${envId} 不存在`);
    }
    
    // 检查环境是否运行中
    if (!environments[envId].controller || !environments[envId].controller.page) {
      throw new Error(`环境 ${envId} 未运行`);
    }
    
    // 检查选择器是否有效
    if (!selector) {
      throw new Error('未提供有效的元素选择器');
    }
    
    const controller = environments[envId].controller;
    
    // 等待选择器并点击
    await controller.page.waitForSelector(selector, { timeout: 3000 });
    await controller.page.click(selector);
    
    res.json({
      success: true,
      message: `已点击元素: ${selector}`
    });
  } catch (error) {
    console.error(`点击元素失败:`, error);
    res.status(500).json({
      success: false,
      message: `点击元素失败: ${error.message}`
    });
  }
});

// 元素检查器输入文本API
app.post('/api/element-explorer/:envId/type', async (req, res) => {
  const envId = req.params.envId;
  const { selector, text } = req.body;
  
  console.log(`在环境 ${envId} 中的元素 ${selector} 输入文本`);
  
  try {
    // 检查环境是否存在
    if (!environments[envId]) {
      throw new Error(`环境 ${envId} 不存在`);
    }
    
    // 检查环境是否运行中
    if (!environments[envId].controller || !environments[envId].controller.page) {
      throw new Error(`环境 ${envId} 未运行`);
    }
    
    // 检查选择器和文本是否有效
    if (!selector) {
      throw new Error('未提供有效的元素选择器');
    }
    
    if (!text) {
      throw new Error('未提供要输入的文本');
    }
    
    const controller = environments[envId].controller;
    
    // 等待选择器
    await controller.page.waitForSelector(selector, { timeout: 3000 });
    
    // 清除现有文本
    await controller.page.evaluate(selector => {
      const element = document.querySelector(selector);
      if (element && (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA')) {
        element.value = '';
      }
    }, selector);
    
    // 输入新文本
    await controller.page.type(selector, text);
    
    res.json({
      success: true,
      message: `已在元素 ${selector} 中输入文本`
    });
  } catch (error) {
    console.error(`输入文本失败:`, error);
    res.status(500).json({
      success: false,
      message: `输入文本失败: ${error.message}`
    });
  }
});

// 辅助函数 - 延迟执行
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 启动服务器
const server = app.listen(port, async () => {
  console.log('===============================================');
  console.log('  AdsPower多环境管理器正在运行 ');
  console.log(`  访问地址: http://localhost:${port}`);
  console.log('===============================================');
  
  // 检查API配置
  if (openaiApiKey) {
    console.log('  - OpenAI API 已配置 ✓');
  } else {
    console.log('  - OpenAI API 未配置 ✗');
  }
  
  if (deepseekApiKey) {
    console.log('  - DeepSeek API 已配置 ✓');
  } else {
    console.log('  - DeepSeek API 未配置 ✗');
  }
  
  console.log('  - 元素探索器已集成 ✓');
  console.log('===============================================');
  
  // 初始化 AdsPower API 连接 - 串行执行，避免并发请求
  try {
    // 等待一段时间再开始API调用，避免启动时请求过于频繁
    console.log('\n等待系统初始化...');
    await sleep(2000);
    
    console.log('\n正在检查AdsPower API连接状态...');
    
    // 先获取分组列表
    try {
      console.log('正在获取分组列表...');
      const groupResponse = await adspowerApi.getGroupList();
      if (groupResponse.code === 0 && Array.isArray(groupResponse.data)) {
        console.log(`获取到 ${groupResponse.data.length} 个分组`);
      } else {
        console.log('获取分组列表失败');
      }
      
      // 等待1秒再请求环境列表
      await sleep(1000);
    } catch (groupError) {
      console.error('获取分组列表失败:', groupError.message);
      // 继续执行，不影响后续操作
      await sleep(2000);
    }
    
    // 然后获取环境列表
    try {
      console.log('正在获取环境列表...');
      // 获取环境列表
      const envResponse = await adspowerApi.getEnvironmentList({
        page: 1,
        page_size: 100
      });
      
      let envCount = 0;
      if (Array.isArray(envResponse.data)) {
        envCount = envResponse.data.length;
      }
      
      console.log('✅ AdsPower API连接成功!');
      console.log(`发现 ${envCount} 个环境`);
    } catch (envError) {
      console.error('❌ 获取环境列表失败:', envError.message);
    }
    
  } catch (error) {
    console.error('❌ AdsPower API连接失败:', error.message);
  }
});

// 重连环境API - 解决元素检查器连接问题
app.post('/api/environment/:envId/reconnect', async (req, res) => {
  const envId = req.params.envId;
  console.log(`尝试重新连接环境 ${envId}`);
  
  try {
    // 检查环境是否存在
    if (!environments[envId]) {
      throw new Error(`环境 ${envId} 不存在`);
    }
    
    // 尝试重新连接浏览器
    const reconnectResult = await reconnectBrowser(envId);
    
    if (reconnectResult.success) {
      console.log(`环境 ${envId} 重新连接成功`);
      res.json({
        success: true,
        message: '环境重新连接成功'
      });
    } else {
      console.error(`环境 ${envId} 重新连接失败: ${reconnectResult.error}`);
      res.json({
        success: false,
        message: `重新连接失败: ${reconnectResult.error}`
      });
    }
  } catch (error) {
    console.error(`重新连接环境 ${envId} 发生错误:`, error);
    res.status(500).json({
      success: false,
      message: `重新连接失败: ${error.message}`
    });
  }
});

// AdsPower API诊断
app.get('/api/diagnostics', async (req, res) => {
  try {
    console.log('正在执行AdsPower API诊断...');
    const diagnosticResults = {};
    
    // 测试环境列表API
    try {
      console.log('测试环境列表API...');
      const options = {
        page: 1,
        page_size: 100
      };
      
      if (req.query.group_id) {
        options.group_id = req.query.group_id;
      }
      
      // 1. 使用标准API客户端
      const standardResponse = await adspowerApi.getEnvironmentList(options);
      
      diagnosticResults.environmentList = {
        success: standardResponse.code === 0,
        code: standardResponse.code,
        message: standardResponse.msg || 'OK',
        dataType: typeof standardResponse.data,
        hasListProperty: standardResponse.data && 'list' in standardResponse.data,
        environmentCount: standardResponse.data && standardResponse.data.list ? standardResponse.data.list.length : 
                         (Array.isArray(standardResponse.data) ? standardResponse.data.length : 0),
        sample: standardResponse.data && standardResponse.data.list && standardResponse.data.list.length > 0 ? 
                standardResponse.data.list[0] : 
                (Array.isArray(standardResponse.data) && standardResponse.data.length > 0 ? standardResponse.data[0] : null)
      };
      
      // 2. 直接使用axios发送请求
      const directUrl = `http://localhost:50325/api/v1/user/list?page=1&page_size=100`;
      console.log('直接请求URL:', directUrl);
      
      const directResponse = await axios.get(directUrl, {
        timeout: 10000,
        headers: { 'Accept': 'application/json' }
      });
      
      diagnosticResults.directRequest = {
        status: directResponse.status,
        success: directResponse.data && directResponse.data.code === 0,
        code: directResponse.data ? directResponse.data.code : undefined,
        message: directResponse.data && directResponse.data.msg ? directResponse.data.msg : 'OK',
        dataType: directResponse.data ? typeof directResponse.data.data : undefined,
        hasListProperty: directResponse.data && directResponse.data.data && 'list' in directResponse.data.data,
        environmentCount: directResponse.data && directResponse.data.data && directResponse.data.data.list ? 
                         directResponse.data.data.list.length : 0,
        sample: directResponse.data && directResponse.data.data && directResponse.data.data.list && 
                directResponse.data.data.list.length > 0 ? directResponse.data.data.list[0] : null
      };
      
      // 3. 运行诊断测试
      diagnosticResults.connectionTest = await checkAdsPowerConnection();
      
      // 生成curl命令供用户测试
      diagnosticResults.testCommands = [
        `curl -v "http://localhost:50325/api/v1/user/list?page=1&page_size=100"`,
        `curl -v "http://local.adspower.net:50325/api/v1/user/list?page=1&page_size=100"`,
        `curl -v "http://127.0.0.1:50325/api/v1/user/list?page=1&page_size=100"`
      ];
    } catch (envError) {
      console.error('环境列表API诊断失败:', envError);
      diagnosticResults.environmentList = {
        success: false,
        error: envError.message
      };
    }
    
    // 测试分组API
    try {
      console.log('测试分组API...');
      const groupResponse = await adspowerApi.getGroups();
      
      diagnosticResults.groups = {
        success: groupResponse.code === 0,
        code: groupResponse.code,
        message: groupResponse.msg || 'OK',
        dataType: typeof groupResponse.data,
        hasListProperty: groupResponse.data && 'list' in groupResponse.data,
        groupCount: groupResponse.data && groupResponse.data.list ? 
                   groupResponse.data.list.length : 
                   (Array.isArray(groupResponse.data) ? groupResponse.data.length : 0)
      };
    } catch (groupError) {
      console.error('分组API诊断失败:', groupError);
      diagnosticResults.groups = {
        success: false,
        error: groupError.message
      };
    }
    
    // 若环境列表API失败，尝试使用备用方法
    if (!diagnosticResults.environmentList.success || diagnosticResults.environmentList.environmentCount === 0) {
      try {
        console.log('使用nativeHttpGet方法测试环境列表API...');
        const nativeResponse = await adspowerApi.nativeHttpGet('http://localhost:50325/api/v1/user/list', {
          page: 1,
          page_size: 100
        });
        
        diagnosticResults.nativeRequest = {
          success: nativeResponse && nativeResponse.code === 0,
          code: nativeResponse ? nativeResponse.code : undefined,
          message: nativeResponse && nativeResponse.msg ? nativeResponse.msg : 'No response',
          dataType: nativeResponse && nativeResponse.data ? typeof nativeResponse.data : undefined,
          hasListProperty: nativeResponse && nativeResponse.data && 'list' in nativeResponse.data,
          environmentCount: nativeResponse && nativeResponse.data && nativeResponse.data.list ? 
                          nativeResponse.data.list.length : 0
        };
      } catch (nativeError) {
        console.error('nativeHttpGet诊断失败:', nativeError);
        diagnosticResults.nativeRequest = {
          success: false,
          error: nativeError.message
        };
      }
    }
    
    res.json({
      success: true,
      diagnostics: diagnosticResults,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('执行诊断时出错:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// 诊断页面
app.get('/diagnostics', (req, res) => {
  res.render('diagnostics');
});

// API测试端点
app.get('/api/test-connection', async (req, res) => {
  try {
    console.log('执行API连接测试...');
    
    // 首先尝试使用标准方法检查连接
    const isConnected = await checkAdsPowerConnection();
    
    if (isConnected) {
      return res.json({
        success: true,
        message: 'AdsPower API连接正常',
        method: 'standard'
      });
    }
    
    // 如果标准方法失败，尝试使用curl测试
    console.log('标准连接测试失败，尝试使用curl...');
    const curlResult = await adspowerApi.testApiWithCurl();
    
    if (curlResult.success) {
      return res.json({
        success: true,
        message: `使用curl测试成功: ${curlResult.message}`,
        method: 'curl',
        data: curlResult
      });
    }
    
    // 两种方法都失败
    return res.json({
      success: false,
      message: '所有连接测试均失败',
      standardTest: isConnected,
      curlTest: curlResult
    });
  } catch (error) {
    console.error('测试API连接时出错:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// 元素检查器 - 重新连接环境
app.post('/api/element-explorer/:envId/reconnect', async (req, res) => {
  const envId = req.params.envId;
  
  console.log(`手动请求重新连接环境 ${envId}`);
  
  try {
    // 检查环境是否存在
    if (!environments[envId]) {
      return res.json({
        success: false,
        message: `环境 ${envId} 不存在`
      });
    }
    
    // 尝试关闭现有控制器
    if (environments[envId].controller) {
      try {
        await environments[envId].controller.close();
        console.log(`成功关闭环境 ${envId} 的现有控制器`);
      } catch (closeError) {
        console.error(`关闭环境 ${envId} 的控制器时出错:`, closeError);
        // 继续尝试重新连接，即使关闭失败
      }
    }
    
    // 调用重连函数
    const reconnectResult = await reconnectBrowser(envId);
    
    if (reconnectResult.success) {
      // 重连成功
      console.log(`环境 ${envId} 重连成功`);
      
      res.json({
        success: true,
        message: '环境重新连接成功，正在刷新页面数据...'
      });
    } else {
      // 重连失败
      console.error(`环境 ${envId} 重连失败:`, reconnectResult.error);
      
      res.json({
        success: false,
        message: `重新连接失败: ${reconnectResult.error}`
      });
    }
  } catch (error) {
    console.error(`重新连接环境 ${envId} 时出错:`, error);
    
    res.json({
      success: false,
      message: `重新连接出错: ${error.message}`
    });
  }
});

// 元素检查器 - 获取页面元素
app.get('/api/element-explorer/:envId/page-elements', async (req, res) => {
  const envId = req.params.envId;
  
  console.log(`获取环境 ${envId} 的页面元素`);
  
  try {
    // 检查环境是否存在并运行
    if (!environments[envId] || !environments[envId].controller || !environments[envId].controller.page) {
      return res.json({
        success: false,
        message: '环境未运行或浏览器未连接'
      });
    }
    
    const controller = environments[envId].controller;
    
    try {
      // 使用超时保护
      const pageOperationWithTimeout = async (operation, timeoutMs, errorMessage) => {
        return Promise.race([
          operation(),
          new Promise((_, reject) => setTimeout(() => reject(new Error(errorMessage)), timeoutMs))
        ]);
      };
      
      // 获取页面元素
      const elements = await pageOperationWithTimeout(
        async () => {
          return controller.page.evaluate(() => {
            // 收集页面上所有可交互元素
            try {
              const selectors = [
                'a', 'button', '[role="button"]', 'input', 'select', 'textarea', '[tabindex]',
                '[onclick]', '[role="link"]', '[role="checkbox"]', '[role="radio"]',
                '[role="tab"]', '[role="menu"]', '[role="menuitem"]', '[role="option"]',
                'area[href]', 'summary', 'details', '[contenteditable="true"]',
                'iframe', 'label', '.clickable', '[class*="btn"]', '[class*="button"]'
              ];
              
              // 查找所有匹配的元素
              const allElements = document.querySelectorAll(selectors.join(','));
              const elements = Array.from(allElements).slice(0, 200);
              
              // 过滤可见元素
              return elements
                .filter(el => {
                  try {
                    const rect = el.getBoundingClientRect();
                    const style = window.getComputedStyle(el);
                    return rect.width > 3 && rect.height > 3 && 
                          style.display !== 'none' && 
                          style.visibility !== 'hidden' && 
                          style.opacity !== '0' &&
                          el.offsetParent !== null;
                  } catch (e) {
                    return false;
                  }
                })
                .map((el, id) => {
                  try {
                    const rect = el.getBoundingClientRect();
                    
                    // 获取元素文本
                    let text = el.innerText || el.textContent || '';
                    if (!text && el.value) text = el.value;
                    if (!text && el.placeholder) text = '(占位符: ' + el.placeholder + ')';
                    if (!text && el.alt) text = '(alt: ' + el.alt + ')';
                    if (!text && el.title) text = '(title: ' + el.title + ')';
                    
                    // 构建选择器
                    let selector = '';
                    if (el.id) {
                      selector = `#${CSS.escape(el.id)}`;
                    } else {
                      selector = el.tagName.toLowerCase();
                    }
                    
                    return {
                      id,
                      tagName: el.tagName.toLowerCase(),
                      text: text.trim().substring(0, 50),
                      selector,
                      rect: {
                        x: rect.left,
                        y: rect.top,
                        width: rect.width,
                        height: rect.height
                      }
                    };
                  } catch (e) {
                    return null;
                  }
                })
                .filter(Boolean);
            } catch (e) {
              console.error('获取元素错误:', e);
              return [];
            }
          });
        },
        10000,
        '获取页面元素超时'
      );
      
      console.log(`获取到 ${elements.length} 个页面元素`);
      
      res.json({
        success: true,
        elements: elements
      });
    } catch (error) {
      console.error(`获取页面元素失败:`, error);
      
      res.json({
        success: false,
        message: `获取页面元素失败: ${error.message}`
      });
    }
  } catch (error) {
    console.error(`处理获取页面元素请求时出错:`, error);
    
    res.json({
      success: false,
      message: `处理请求出错: ${error.message}`
    });
  }
});

